# 牛客、力扣Java算法刷题

## 牛客、力扣算法刷题方法
1. 分类的去刷题；比如先做数组链表类，再做树类，再做dp类等等，形成一个知识体系；不要东一锤西一棒去刷题，这样子效率不高；
2. 勤做笔记，在代码上写好注释，在笔记本上记下一些关键字、自己的思路以及自己没有想到的新技巧，这样子每次回顾的时候可以串联起来；
3. 勤复习，记在笔记里的一些思路等等要经常去看，温故而知新；可以考虑每天花一分钟复习，一周花一分钟复习；
4. 死磕精神，精益求精，下意识的去想优秀的代码，同时多看评论区大神的代码，和他们去比较，看看自己的优点在哪缺点在哪；
5. bug free，熟悉语法和数据结构，写代码时更细心，以此来保证程序少bug、没有bug，如果刷题时bug，可以把问题出现的原因、为何会出现bug、如何解决也记在笔记上；
6. 反应要快，写代码要快，刻意去训练，刻意伪装再继续训练，直到习以为常；

## 算法
算法特征：有穷性、确定性、可行性、有输入、有输出
设计原则：正确性、可读性、健壮性；高效率和低存储（内存占用最小、CPU占用最小、运算速度快）
时间复杂度：运行一个代码所需时间；
空间复杂度：运行一个程序所需要的内存；

### 时间复杂度
1. 时间复杂度的意义：
平时一般使用压测和冒烟测试接口的性能，但是需要依赖测试环境，可能结果的规模或者数据不准确。所以还是需要自己去用代码进行分析，也就是去分析时间复杂度。
2. 几种常见的时间复杂度分析（某一段代码 ）：
计算时间复杂度往往是计算比较大的而且是不确定的数，如果已经确定了，那么就不要计算了，也就是我们说的常量。
常数：O(1)，1表示常数，所有能确定的数我们都用O(1)。
对数：O(logn),O(nlogn)
线性：O(n)
线性对数：O(nlogn)
平方：O(n^2)
多次方：O(n^x)
3. 计算时间复杂度的时候，有加减法时，找次数最高的那个
4. 找时间复杂度：
    a. 找有循环的地方
    b. 找有网络请求（RPC：一般在分布式的远程调用；数据库请求）的地方；就是测试时间：log打印，计算平均时间。
5. 学时间复杂度的目的就是为了把代码写到最优，效率最高，目标就是往O(1)的方向靠近：
    O(1)>O(logn)>O(n)>O(nlogn)>O(n^2)>O(n^x)
    O(1)>O(logn)>O(n)>O(nlogn)效果都是很好的，几乎优化的空间不是很大

### 空间复杂度
1. 空间复杂度：找花了内存的地方
2. 如何找出程序的空间复杂度：开了空间的地方:数组，链表，缓存对象，递归等

### 先来一道下酒菜：获取从1到50中所有的2的N次方的数：
输出的应该就是：2、4、8、16、32；
如何判断是2的N次方呢？
方法1：
    ```java
    while(n>1){
        if(n%2!=0){
            return false;
        }
        n=n/2;
    }
    return true;
    ```
    光判断是否为2的N次方，其时间复杂度就是O(logn)
方法2：
我们可以发现：
|十进制  |二进制  |
|------ |-----  |
    1   |   01
    2   |   10
    3   |   011
    4   |   100
    5   |   0101
    6   |   0110
    ……  |   ……
且当n>1时：
10 & 01 = 0；
100 & 011 = 0；
1000 & 0111 = 0;
……
而：
0110 & 0101 = 100;
……
综上可知：
    ```java
    if(n&(n-1)==0&&n>1)
        return true;
    return false;
    ```
   时间复杂度为O(1)