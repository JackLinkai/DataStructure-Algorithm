# 牛客、力扣Java算法刷题

## 牛客、力扣算法刷题方法
1. 分类的去刷题；比如先做数组链表类，再做树类，再做dp类等等，形成一个知识体系；不要东一锤西一棒去刷题，这样子效率不高；
2. 勤做笔记，在代码上写好注释，在笔记本上记下一些关键字、自己的思路以及自己没有想到的新技巧，这样子每次回顾的时候可以串联起来；
3. 勤复习，记在笔记里的一些思路等等要经常去看，温故而知新；可以考虑每天花一分钟复习，一周花一分钟复习；
4. 死磕精神，精益求精，下意识的去想优秀的代码，同时多看评论区大神的代码，和他们去比较，看看自己的优点在哪缺点在哪；
5. bug free，熟悉语法和数据结构，写代码时更细心，以此来保证程序少bug、没有bug，如果刷题时bug，可以把问题出现的原因、为何会出现bug、如何解决也记在笔记上；
6. 反应要快，写代码要快，刻意去训练，刻意伪装再继续训练，直到习以为常；

## 算法
算法特征：有穷性、确定性、可行性、有输入、有输出
设计原则：正确性、可读性、健壮性；高效率和低存储（内存占用最小、CPU占用最小、运算速度快）
时间复杂度：运行一个代码所需时间；
空间复杂度：运行一个程序所需要的内存；

### 时间复杂度
1. 时间复杂度的意义：
平时一般使用压测和冒烟测试接口的性能，但是需要依赖测试环境，可能结果的规模或者数据不准确。所以还是需要自己去用代码进行分析，也就是去分析时间复杂度。
2. 几种常见的时间复杂度分析（某一段代码 ）：
计算时间复杂度往往是计算比较大的而且是不确定的数，如果已经确定了，那么就不要计算了，也就是我们说的常量。
常数：O(1)，1表示常数，所有能确定的数我们都用O(1)。
对数：O(logn),O(nlogn)
线性：O(n)
线性对数：O(nlogn)
平方：O(n^2)
多次方：O(n^x)
3. 计算时间复杂度的时候，有加减法时，找次数最高的那个
4. 找时间复杂度：
    a. 找有循环的地方
    b. 找有网络请求（RPC：一般在分布式的远程调用；数据库请求）的地方；就是测试时间：log打印，计算平均时间。
5. 学时间复杂度的目的就是为了把代码写到最优，效率最高，目标就是往O(1)的方向靠近：
    O(1)>O(logn)>O(n)>O(nlogn)>O(n^2)>O(n^x)
    O(1)>O(logn)>O(n)>O(nlogn)效果都是很好的，几乎优化的空间不是很大

### 空间复杂度
1. 空间复杂度：找花了内存的地方
2. 如何找出程序的空间复杂度：开了空间的地方:数组，链表，缓存对象，递归等

### 先来一道下酒菜：获取从1到50中所有的2的N次方的数：
输出的应该就是：2、4、8、16、32；
如何判断是2的N次方呢？
方法1：
    ```java
    while(n>1){
        if(n%2!=0){
            return false;
        }
        n=n/2;
    }
    return true;
    ```
方法2：
我们可以发现：
|十进制  |二进制  |
|------ |-----  |
    1   |   01
    2   |   10
    3   |   011
    4   |   100
    5   |   0101
    6   |   0110
    ……  |   ……
且当n>1时：
10 & 01 = 0；
100 & 011 = 0；
1000 & 0111 = 0;
……
而：
0110 & 0101 = 100;
……
综上可知：
    ```java
    if(n&(n-1)==0&&n>1)
        return true;
    return false;
    ```

## 数组和字符串
https://leetcode-cn.com/explore/featured/card/array-and-string/
数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。
我们在这一章的目标是：
1. 理解数组的 基本概念 及其 操作方式；
2. 理解 二维数组 的基本概念，熟悉二维数组的使用；
3. 了解 字符串 的概念以及字符串所具有的不同特性；
4. 理解字符串匹配中的 KMP 算法；
5. 能够运用 双指针 解决实际问题。

### 数组
1. 集合：由一个或多个确定的元素所构成的整体。集合里的元素类型不一定相同；集合里的元素没有顺序。
2. 列表：列表（又称线性列表），是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。
    列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。
    在编程语言中，列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。
3. 数组：在Java中，首先数组的元素类型必须保持一致，其次数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。
    数组是列表的实现方式之一，不同于列表，数组有索引，而列表没有索引。
    a. 数组定义：所谓数组，是有序的元素序列，若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了方便处理，把具有相同类型的若干元素按无序排列的形式组织起来的一种形式。这些无序排列的同类数据元素的集合称其为数组。
    数组是用于存储多个相同类型数据的集合，通常用Array表示，也称为线性表。
    b. 特点：
       (1)数组是相同数据类型的元素的集合。
       (2)数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起，即内存地址。但元素不一定是按照特定顺序进行排列的。
       (3)数组元素用整个数组的名字和它自己在数组中的顺序位置来表示。例如，a[0]表示名字为a的数组中的第一个元素，a[1]代表数组a的第二个元素，以此类推。
    c. 表现形式
        (1)一维数组：int a[],String a[]
        (2)多维数组：int a[][],int a[][][]。
        int a[m][n]:内存空间是多少？ m*n，且内存空间在初始化时就已经分配好了。
    d.**随机访问**：数组是连续的内存空间和相同类型的数据。
        正是因为这两个限制，它才有了一个非常重要的特性：随机访问。
        但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。
    e. **使用数组一定要注意访问越界问题。**所以一定要多加判断，尤其在开始和结束，测试的时候也需要注意头和尾。

#### 数组的操作
1. 读取元素：通过数组的索引访问数组中的元素。
当申明一个数组的时候，计算机会在内存中申请一段 连续 的空间，并且会记下索引为 0 处的内存地址。
因为数组是连续的，所以要找到对应索引的内容只需要得到该索引所对应的内存地址即可，而且计算机可以跳跃到任意的内存地址上，因此只要计算出数组中元素的内存地址，则可以一步访问到数组中的元素。
可以将整个访问过程只看作一个动作，因此时间复杂度为 O(1)。
2. 查找元素：
计算机只会保存数组中索引为 0 处元素的内存地址，因此当计算机想要知道数组中是否包含某个元素时，只能从索引 0 处开始，逐步向后查询。
在最坏情况下，我们需要查询数组中的每个元素，因此时间复杂度为 O(n)，n 为数组的长度。
3. 插入元素：
如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可，时间复杂度为 O(1)。
如果要将该元素插入到数组中的其他位置，我们首先需要为该元素所要插入的位置腾出空间，这样就需要把目标位置的元素及其后面的元素一个个地往后稍稍，然后进行插入操作，时间复杂度为 O(n)，n 为数组的长度。
4. 删除元素
删除元素与插入元素的操作类似，如果是删除末尾的元素，只需要删除即可，时间复杂度为 O(1)。
当我们删除掉数组中其他位置的某个元素后，数组中会留下 空缺 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 填补 操作，时间复杂度为 O(n)，n 为数组的长度。
总结：因此我们在进行数据操作时，类似于需要读取元素、插入或删除最后一个元素的，可以考虑使用数组。

#### ArrayList和数组
本质是一样的，都是数组。ArrayList是JDK封装的数组，不需要管扩容等操作，数组就需要自己全部操作。所以使用数组会比使用ArrayList性能高。
两者之间如何选用：
1. 不知道数据大小选ArrayList；
2. 若知道数据的大小且非常关注性能，则选择使用数组。

#### Java中的内存：堆内存&栈内存
堆内存：存放new创建的对象和数组
栈内存：引用变量
堆栈都是Java用来存放数据的地方，Java自动管理堆栈（GC机制）
区别：
    1. 栈的速度更快
    2. 栈内存的数据可以共享，主要存一些基本的数据类型
    *** int a = 3；  //在栈中创建变量a，然后给a赋值，先不会创建一个3，而是在栈中找有没有3，如果有直接指向，如果没有就加一个3进来
如：
1.
    String str1 = "abc";
    String str2 = "abc";
    System.out.println(str1 == str2);   //输出的是true，他们都是指向栈中的同一个引用
2.
    String str1 = "abc";
    String str2 = "abc";
    srt1 = "bcd";
    System.out.println(str1 + ","+ str2);      //输出bcd,abd
    System.out.println(str1 == str2);          //输出false，虽然一开始str1和str2都指向同一个变量abc，但是srt1的重新引用不会影响str2的引用
3.
    String str1 = "abc";
    String str2 = "abc";
    srt1 = "bcd";
    String str3 = str1；
    System.out.println(str3);           //输出的是bcd，和str1指向同一个引用
    String str4 = "bcd";
    System.out.println(str1 == str4);   //true，str1和str4指向同一个引用
4.
    String str1 = new String("abc");    //new创建的对象在堆内存中
    String str2 = "abc";
    System.out.println(str1 == str2);   //所以是false
5.
    String str1 = "ja";
    String str2 = "va";
    String str3 = "java";
    String str4 = str1 + str2;
    System.out.println(str3 == str4);       //false，这里的+号在java里面重载了，调用了StringBuild，所以还是new对象了，在堆内存中
    System.out.println(str3.equals(str4));  //true，在这里的equals方法只是对比二者的值

#### 数组下标为什么从0开始
定义一个数组一定会分配内存空间，数组的特点是在内存的一段连续的地址。
假如说我们定义一个数组，在内存中是10001开始申请空间的，那么底层申请空间是这样子的：
a[0]:10001+0*typesize
a[1]:10001+1*typesize
a[2]:10001+2*typesize
……
因为数组在内存是连续的一段地址，所以只需要记住a[0]的地址就可以计算出其他的内存地址，实现随机访问；
但是如果下标从1开始的话：
a[1]:10001+(1-1)*typesize
a[2]:10001+(2-1)*typesize
a[3]:10001+(3-1)*typesize
……
由于在底层计算中，减法运算很复杂，如果要涉及减法运算的话性能不高，所以数组的下标会选择从0开始而不是其他的数字开始的。
一维数组的寻址公式就是：loc(a[index])=init_loc（初始化内存地址）+index*typesize（数据长度）

#### 例题1：
给你一个文件里面包含全国人民（14亿）的年龄数据（0~180），现在要你统计每一个年龄有多少人？
给定机器为 单台+2CPU+2G内存。不得使用现成的容器，比如map等。
#### 例题2：
设数组的长度为n，现在，如果我们需要将一个数据插入到数组中的第k个位置。删除第n个位置的数据.

# 数组总结
数组是存储同种类型元素的一组数据，最大的优点是下标和随机访问；缺点是插入和删除很慢，时间复杂度为O(n);
1. 巧妙使用下标，下标不仅仅可以用来做标记，也可以用来做有意义的数据，比如例题1；
2. 巧妙运用数组的随即访问，直接通过下标定位到数组中的某一个数据，时间复杂度为O(1)；
3. 在需要使用对数据进行插入和删除时，如果不是尾插和尾删，则不要考虑数组为好。

## 二维数组的寻址公式
可以把二维转为一维来计算：
arr[a+1][b+1]:
arr[0][0]:10001+0*b*typesize+0*typesize
arr[0][1]:10001+0*b*typesize+1*typesize
……
arr[0][b]:10001+0*b*typesize+b*typesize
arr[1][0]:10001+1*(b+1)*typesize+0*typesize
……
arr[1][b]:10001+1*(b+1)*typesize+b*typesize
arr[2][0]:10001+2*(b+2)*typesize+0*typesize
……
arr[a][b]:10001+a*(b+1)*typesize+b*typesize
因此，二维数组的寻址公式：
loc(a[i][j](0<=i<n,0<=j<m))=init_loc+(i*m+j)*typesize

## 稀疏数组
稀疏数组一般针对多维数组，就是存的数据远远的小于初始化该数组时开辟的空间（好多空间没有使用，都空着，存储了数据的空间不一定都连续），这种情况往往就可以使用链表来代替它。

# 链表
## 链表的定义
链表通过指针将一组**零散的**内存块串联在一起，其中，我们把内存块称为链表的“结点”。为了把所有的结点串联起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。
所以我们可以看出，链表首先是不能像数组一样可以随即访问的，并且同样长度的链表占用的内存空间也会比数组大。
总结出的特点：
1. 不需要连续的内存空间
2. 有指针引用
3. 三种最常见的链表结构：单链表、双向链表和循环链表
## 单链表
从单链表图中，可以发现，有两个结点比较特殊，它们分别是第一个结点（叫头结点）和最后一个结点（叫尾结点）；其中，头结点用来记录链表的基地址，我们可以用它来遍历得到整条链表；尾结点的指针不是指向下一个结点，而是指向一个空地址NULL，表示这是链表的最后一个结点。
单链表的查找、插入和删除：
1.

## 循环链表
循环链表是一种特殊的单链表。单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点，如同一个环一样首尾相连，所以叫做“循环”链表。

## 双向链表
单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。双向链表，顾名思义，它支持两个方向，每个结点不只有一个后继指针next指向后面的结点，还有一个前驱指针prev指向前面的结点。双向链表需要额外两个空间来存储后继结点和前驱结点的地址。
因此存储同样多的数据，双向链表会比单向链表占用更多的内存空间。不过因为支持双向遍历，比起单向链表在数据的操作上也是更加的灵活。
在实际的应用上比如MySQL数据库索引底层的B+树它的叶子节点就是一个双向链表。


## 例题1：设计一个LRU缓存淘汰算法
最近使用，只需要维护一个有序的单链表就可以了。有序的指的就是加入的时间排序
思路：新加一个点，如果在链表里面找到了，删掉然后插入到头部，头部就是最新的；如果不在原来的链表，有空间就插入到头部，没有空间就删除最后一个结点然后插入到头部。

## 例题2：约瑟夫问题（丢手绢）
约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3，1。
现在问你最后留下的人是谁？
比如N=6，M=5
留下的就是1
1 2 3 4 5 6 => 6 1 2 3 4 => 6 1 2 3 =>1 2 3 => 1 3 => 1
思路：单循环链表

画单链表、双向链表、循环链表、双向循环链表的图


# 数组和链表的区别：
|时间复杂度|数组|链表|
|--|--|--|
插入删除|O(n)|O(1)
随即访问|O(1)|O(n)
1. 数组简单易用，在实现上使用的是**连续**的内存空间，`可以借助CPU的缓存机制预读数组中的数据，所以访问效率更高（CPU的空间局部性原理）`
2. 链表在内存中并不是连续存储的，所以对CPU的缓存不友好，没办法有效预读
3. 数组的缺点是大小固定，一经声明就要占用整块连续的内存空间。如果声明的数组过大，系统可能没有足够的连续的内存空间分配给它，导致“内存不足（out of memory）”；如果声明的数组过小，则可能出现不够用的情况。
4. 动态扩容：数组需要再申请一个更大的内存空间（ArrayList内部的扩容机制为扩容因子0.75，长度为原来的2倍），把原数组拷贝进去，很耗时间。链表本身没有大小限制，天然地支持动态扩容。

# 栈
实现后进先出（Last In First Out）的一种数据结构。
一个限定只在表尾进行插入和删除的线性表（数组或链表）。表尾这一端被称为栈顶，相对地，另一端被称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素上面变成新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
栈其实是一个特殊的链表或数组。

## 栈的分类：
1. 基于数组的栈——以数组为底层数据结构时，通常数组头是栈底，数组头到数组尾是栈顶的生长方向；
2. 基于单链表的栈——以链表为底层数据结构时，以链表头为栈顶，便于节点的插入和删除，压栈产生新的节点将一直出现在链表的头部。
两者最大的区别是扩容，由于链表天然支持动态扩容，很容易出现栈溢出。

## 例题1：设计一个括号匹配的功能
给定一串括号判断是否符合我们的括号原则，如：
[(){()}()] 符合
{}{}}] 不符合

## 设计浏览器的前进后退功能
两个栈
