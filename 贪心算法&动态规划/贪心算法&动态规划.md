# 贪心算法

## 概念

贪心算法又叫做贪婪算法，它在求解过程是多步判断，每步判断时不考虑子问题的计算结果，而是根据当时的情况采取某种“只顾眼前”的贪心策略来决定取舍，所以它是局部最优解。

核心点：通过局部最优推出全局最优。

著名的图的最小生成树的Prim算法和Kruskal算法、单源最短路径的Dijkstra算法、数据压缩的Huffman算法等都使用贪心算法实现。

## 例题1

有n项活动申请使用同一个礼堂，每项活动有一个开始时间和一个结束时间，如果任何两个活动不能同时举行，问如何选择这些活动？

思路：我们可以先按照结束时间从小到大排序，首先把第一个活动加入我们可以举办的列表，之后的活动只要开始时间大于列表中最后一个活动的结束时间就可以把活动添加到可以举办的列表中。

[https://github.com/JackLinkai/DataStructure-Algorithm/blob/master/src/main/algorithm/greedy/GreedyActive.java](https://github.com/JackLinkai/DataStructure-Algorithm/blob/master/src/main/algorithm/greedy/GreedyActive.java)

## 总结

贪心算法一定有一个套路，那就是排序。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程都不会影响以后的状态，只与当前的状态有关。

一般遇到一下问题可以通过贪心解决：

1. 针对某个问题有限制值，以及有一个期望的最好结果，通常是从某些数据中选出其中一些，达到最好的结果。

2. 一般会有一个排序，找出贡献最大的。

3. 举例看贪心是否可以解决。

一般用在任务调度，教师排课等系统都可以考虑用贪心算法解决。

实际上，用贪心算法解决问题的思路，并不总能给出最优解，比如来看下一个问题：

## 背包问题

小偷去某商店盗窃，背有一个背包，容量是50kg，现在有以下物品（物品不能切分,且只有一个），请问小偷应该怎么拿才能得到最大的价值？

|       | 重量 | 价值  |
| ----- | ---- | ----- |
| 物品1 | 10kg | 60元  |
| 物品2 | 20kg | 100元 |
| 物品3 | 40kg | 120元 |

很显然，使用贪心算法并不能解决问题。

我们发现，没有物品都有选择和不选择两种情况，所以我们可以尝试去枚举每一种情况。但是如果有n个商品，就会有2^n个排列组合，这是指数级别的，显然不能考虑这种做法。

想要解决这样的问题，或许就需要动态规划技术来帮忙了：

# 动态规划

动态规划（dynamic programming）是运筹学的一个分支，是求解决策过程（decision process）最优化的数学方法。

动态规划技术已经广泛应用在许多组合优化问题的算法设计中，*比如**图的多起点与多终点的最短路径问题**、矩阵链的乘法问题、最大效益投资问题、背包问题、**最长公共子序列问题**、图像压缩问题、最大字段和问题、最优二分搜索树问题、RNA最优二级结构问题、**短字符相似度匹配**等*。

动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。

线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；

区域动规：石子合并，加分二叉树，统计单词个数，炮兵布阵等；

树形动规：贪吃的九头龙，二分查找书，聚会的欢乐，数字三角形等；

背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶等；

动态规划算法通常用于求解具有某种**最优性质**的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是**将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解**。与分治法不同的是，适合于用动态规划求解的问题，**经分解得到子问题往往不是互相独立的**。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以**用一个表来记录所有已解的子问题的答案**。**不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。**这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

能采用动态规划解决的问题，一般要具有三个性质：

1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

2. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

3. 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

动态规划问题，大致可以通过以下四步进行解决。

1. 划分状态，即划分子问题

2. 状态表示，即如何让计算机理解子问题

3. 状态转移，即父问题是如何由子问题推导出来的

4. 确定边界，确定初始状态是什么？最小的子问题？最终状态又是什么

## 动态规划的一般思路

动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

1. 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

2.  确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。

3. 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。

4. 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。

实际应用中可以按以下几个简化的步骤进行设计：

（1）分析最优解的性质，并刻画其结构特征。

（2）递归的定义最优解。

（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值

（4）根据计算最优值时得到的信息，构造问题的最优解

## 例题二——背包问题

回到上面的背包问题，我们可以把50kg的背包，拆分成10kg、10kg这样子计算，里面的表格就表示当前容量量下能装的最大价值，如表：

|           | 10kg | 20kg | 30kg | 40kg | 50kg |
| --------- | ---- | ---- | ---- | ---- | ---- |
| 加入物品1 | 60   | 60   | 60   | 60   | 60   |
| 加入物品2 | 60   | 100  | 160  | 160  | 160  |
| 加入物品3 | 60   | 100  | 160  | 160  | 180  |

解释：

1. 在加入物品1之后，由于物品1的重量为10kg，所以在背包容量为10kg及以上时可以装入物品1，最大价值为60元

2. 加入物品2之后

   * 背包容量为10kg依旧只能装物品1，最大价值为60元
   * 背包容量为20kg时，可以装物品2，装物品2价值100元，不装物品2装物品1价值60元，所以选择装物品2
   * 背包容量为30kg及以上时，物品1和物品2都可以装，价值160元

3. 加入物品3之后

   * 物品3的重量为40kg，在背包容量小于40kg时同上状态
   * 背包容量为40kg时，如果装物品3，价值为120元，如果装物品1和物品2，价值为160元，所以装物品1和物品2
   * 背包容量为50kg时，由于装入物品1和物品3的价值为180元大于装入物品1和物品2价值为160元，所以装物品1和物品3

   最终得出小偷得到的物品的最大价值为180元。

上面这一个递推过程总结起来就是一个东西------**状态转移方程**：

能装的时候就把装了的价值和不装的价值做比较，大就装，否则就不装。

`Max(money[i]+res[i-1][w-weight[i]],res[i-1][w]);`

`money[i]+res[i-1][w-weight[i]]`:装这个物品

`w-weight[i]` :表示装完还剩下的空间

`res[i-1][w-weight[i]]`:表示装完后剩下的空间还能装的最大值，取上一次的结果。

`Res[i-1`][w]表示不装这个物品的值

[https://github.com/JackLinkai/DataStructure-Algorithm/blob/master/src/main/algorithm/dynamicprogramming/Backpack.java](https://github.com/JackLinkai/DataStructure-Algorithm/blob/master/src/main/algorithm/dynamicprogramming/Backpack.java)

## 总结

状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。

## 例题3

双十一马上就要来了，小C心目中的女神在购物车加了N个东西，突然她中了一个奖可以清空购物车5000元的东西（不能找零），每个东西只能买一件，那么她应该如何选择物品使之中奖的额度能最大利用呢？如果存在多种最优组合你只需要给出一种即可（要求还要输出选择商品的策略）

[https://github.com/JackLinkai/DataStructure-Algorithm/blob/master/src/main/algorithm/dynamicprogramming/ShoppingCart.java](https://github.com/JackLinkai/DataStructure-Algorithm/blob/master/src/main/algorithm/dynamicprogramming/ShoppingCart.java)
